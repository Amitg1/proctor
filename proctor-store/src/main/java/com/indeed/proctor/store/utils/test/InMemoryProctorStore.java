package com.indeed.proctor.store.utils.test;

import com.google.common.collect.Maps;
import com.indeed.proctor.common.model.TestDefinition;
import com.indeed.proctor.common.model.TestMatrixDefinition;
import com.indeed.proctor.common.model.TestMatrixVersion;
import com.indeed.proctor.store.ChangeMetadata;
import com.indeed.proctor.store.ProctorStore;
import com.indeed.proctor.store.Revision;
import com.indeed.proctor.store.RevisionDetails;
import com.indeed.proctor.store.StoreException;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.time.Instant;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.LongSupplier;
import java.util.stream.Collectors;

/**
 * This class is an in-memory implementation of ProctorStore.
 * It's for testing purpose and not production ready.
 * <p>
 * These are design notes of this in-memory store.
 * <p>
 * Initially it stores following data
 * * a single dummy revision in matrix history.
 * * no test definition.
 * <p>
 * the dummy revision is required for the following purpose.
 * * getLatestVersion() can avoid an exception even in initialized state.
 * * getCurrent*() can avoid an exception as they relies on getLatestVersion()
 * <p>
 * Revision id is a sequential number generated by supplier given in constructor.
 * If you initialize this store with default constructor,
 * first revision id is "0" and first update will create a revision "1".
 * If you want to control revision id generation
 * (e.g. if you want to make sure it's unique in more than single stores),
 * create and pass to the constructor your custom number generator.
 * <p>
 * Internally, it stores three data structures to support all queries.
 * * globalHistory: a linked list of update records order by recency
 * * testHistories: a map of liked lists of update records order by recency. it's grouped by test name.
 * * revisionIdIndex : a map from revision id to the corresponding update record
 */
public class InMemoryProctorStore implements ProctorStore {
    private final List<UpdateRecord> globalHistory = new LinkedList<>();
    private final Map<String, List<UpdateRecord>> testHistories = new HashMap<>();
    private final Map<RevisionId, UpdateRecord> revisionIdIndex = new HashMap<>();

    private final RevisionIdGenerator revisionIdGenerator;

    private static final ChangeMetadata INITIAL_CHANGE_METADATA = ChangeMetadata.builder()
            .setUsernameAndAuthor("proctor")
            .setPassword("password")
            .setTimestamp(Instant.EPOCH)
            .setComment("initialize in-memory store")
            .build();

    public InMemoryProctorStore() {
        this(new AtomicLong(0)::getAndIncrement);
    }

    public InMemoryProctorStore(final LongSupplier sequentialNumberGenerator) {
        this.revisionIdGenerator = new RevisionIdGenerator(sequentialNumberGenerator);
        insertNewRecord(INITIAL_CHANGE_METADATA, null);
    }

    @Override
    public String getName() {
        return InMemoryProctorStore.class.getSimpleName();
    }

    // --- reader ---

    @Nonnull
    @Override
    public synchronized String getLatestVersion() {
        return globalHistory.get(0).revision.getRevision();
    }

    @Override
    public synchronized TestMatrixVersion getTestMatrix(final String revisionIdStr) throws StoreException {
        final RevisionId revisionId = RevisionId.parse(revisionIdStr);
        checkRevisionIsKnown(revisionId);

        final Map<String, TestDefinition> allTests = new HashMap<>();
        for (final UpdateRecord record : globalHistory) {
            final TestEdit testEdit = record.testEdit;
            if (revisionId.isSameOrAfter(record.revision) && testEdit != null) {
                if (!allTests.containsKey(testEdit.testName)) {
                    allTests.put(testEdit.testName, testEdit.definition);
                }
            }
        }

        final Revision revision = revisionIdIndex.get(revisionId).revision;
        return new TestMatrixVersion(
                new TestMatrixDefinition(
                        Maps.filterValues(allTests, Objects::nonNull) // remove deleted tests
                ),
                revision.getDate(),
                revision.getRevision(),
                revision.getMessage(),
                revision.getAuthor()
        );
    }

    @CheckForNull
    @Override
    public synchronized TestDefinition getTestDefinition(
            final String testName,
            final String revisionIdStr
    ) throws StoreException {
        final RevisionId revisionId = RevisionId.parse(revisionIdStr);
        checkRevisionIsKnown(revisionId);

        final List<UpdateRecord> testHistory = testHistories.get(testName);
        if (testHistory == null) {
            return null;
        }

        return testHistory.stream()
                .filter(r -> revisionId.isSameOrAfter(r.revision))
                .findFirst()
                .map(r -> Objects.requireNonNull(r.testEdit))
                .map(t -> t.definition)
                .orElse(null);
    }

    @Nonnull
    @Override
    public synchronized List<Revision> getMatrixHistory(final int start, final int limit) {
        return globalHistory.stream()
                .map(r -> r.revision)
                .skip(start)
                .limit(limit)
                .collect(Collectors.toList());
    }

    @Nonnull
    @Override
    public synchronized List<Revision> getMatrixHistory(
            final Instant sinceInclusive,
            final Instant untilExclusive
    ) {
        return globalHistory.stream()
                .map(r -> r.revision)
                .filter(r -> !r.getDate().toInstant().isBefore(sinceInclusive)
                        && r.getDate().toInstant().isBefore(untilExclusive))
                .collect(Collectors.toList());
    }

    @Nonnull
    @Override
    public synchronized List<Revision> getHistory(
            final String testName,
            final String revisionIdStr,
            final int start,
            final int limit
    ) throws StoreException {
        final RevisionId revisionId = RevisionId.parse(revisionIdStr);
        checkRevisionIsKnown(revisionId);

        final List<UpdateRecord> testHistory = testHistories.get(testName);
        if (testHistory == null) {
            return Collections.emptyList();
        }

        return testHistory.stream()
                .map(r -> r.revision)
                .filter(revisionId::isSameOrAfter)
                .skip(start)
                .limit(limit)
                .collect(Collectors.toList());
    }

    @CheckForNull
    @Override
    public synchronized RevisionDetails getRevisionDetails(final String revisionIdStr) throws StoreException {
        final RevisionId revisionId = RevisionId.parse(revisionIdStr);
        checkRevisionIsKnown(revisionId);

        return revisionIdIndex.get(revisionId).toRevisionDetails();
    }

    @Nonnull
    @Override
    public synchronized Map<String, List<Revision>> getAllHistories() {
        return testHistories.entrySet().stream()
                .collect(Collectors.toMap(
                        e -> e.getKey(),
                        e -> e.getValue().stream()
                                .map(r -> r.revision)
                                .collect(Collectors.toList())
                ));
    }

    @Override
    public synchronized TestMatrixVersion getCurrentTestMatrix() throws StoreException {
        return getTestMatrix(getLatestVersion());
    }

    @CheckForNull
    @Override
    public synchronized TestDefinition getCurrentTestDefinition(final String testName) throws StoreException {
        return getTestDefinition(testName, getLatestVersion());
    }

    @Nonnull
    @Override
    public synchronized List<Revision> getHistory(
            final String testName,
            final int start,
            final int limit
    ) throws StoreException {
        return getHistory(testName, getLatestVersion(), start, limit);
    }

    // --- writer ---

    @Override
    public synchronized void addTestDefinition(
            final ChangeMetadata changeMetadata,
            final String testName,
            final TestDefinition testDefinition,
            final Map<String, String> metadata
    ) throws StoreException.TestUpdateException {
        if (getTestState(testName) != TestState.NOT_CREATED) {
            throw new StoreException.TestUpdateException(testName + " has been added before");
        }

        insertNewRecord(changeMetadata, new TestEdit(testName, testDefinition));
    }

    @Override
    public synchronized void updateTestDefinition(
            final ChangeMetadata changeMetadata,
            final String previousVersion,
            final String testName,
            final TestDefinition testDefinition,
            final Map<String, String> metadata
    ) throws StoreException.TestUpdateException {
        if (getTestState(testName) != TestState.ALIVE) {
            throw new StoreException.TestUpdateException(testName + " already deleted or not yet added");
        }
        if (!previousVersion.equals(getPreviousRevision(testName))) {
            throw new StoreException.TestUpdateException(
                    "Expected previous version is "
                            + getPreviousRevision(testName)
                            + " but " + previousVersion
            );
        }
        if (testDefinition.equals(getPreviousDefinition(testName))) {
            throw new StoreException.TestUpdateException(
                    "Attempting to save test definition without changes for test: "
                            + testName
            );
        }

        insertNewRecord(changeMetadata, new TestEdit(testName, testDefinition));
    }

    @Override
    public synchronized void deleteTestDefinition(
            final ChangeMetadata changeMetadata,
            final String previousVersion,
            final String testName,
            final TestDefinition testDefinition
    ) throws StoreException.TestUpdateException {
        if (getTestState(testName) != TestState.ALIVE) {
            throw new StoreException.TestUpdateException(testName + " already deleted or not yet added");
        }
        if (!previousVersion.equals(getPreviousRevision(testName))) {
            throw new StoreException.TestUpdateException(
                    "Expected previous version is "
                            + getPreviousRevision(testName)
                            + " but " + previousVersion
            );
        }

        insertNewRecord(changeMetadata, new TestEdit(testName, null));
    }

    // no-op methods

    @Override
    public boolean cleanUserWorkspace(final String username) {
        return false;
    }

    @Override
    public void verifySetup() {
    }

    @Override
    public void refresh() {
    }

    @Override
    public void close() {
    }

    // utility classes and methods

    private void insertNewRecord(
            final ChangeMetadata changeMetadata,
            @Nullable final TestEdit testEdit
    ) {
        final RevisionId revisionId = revisionIdGenerator.generate();
        final Revision revision = new Revision(
                revisionId.toString(),
                changeMetadata.getAuthor(),
                Date.from(changeMetadata.getTimestamp()),
                changeMetadata.getComment()
        );
        final UpdateRecord record = new UpdateRecord(revision, testEdit);

        globalHistory.add(0, record);
        if (record.testEdit != null) {
            final String testName = record.testEdit.testName;
            testHistories.computeIfAbsent(testName, k -> new LinkedList<>())
                    .add(0, record);
        }
        revisionIdIndex.put(revisionId, record);
    }

    private UpdateRecord getLatestUpdate(final String testName) {
        final List<UpdateRecord> testHistory = testHistories.get(testName);
        if (testHistory == null || testHistory.isEmpty()) {
            return null;
        }

        return testHistory.get(0);
    }

    private String getPreviousRevision(final String testName) {
        final UpdateRecord latestUpdate = getLatestUpdate(testName);
        if (latestUpdate == null) {
            throw new IllegalArgumentException("expected to have " + testName);
        }

        return latestUpdate.revision.getRevision();
    }

    private TestDefinition getPreviousDefinition(final String testName) {
        final UpdateRecord latestUpdate = getLatestUpdate(testName);
        if (latestUpdate == null) {
            throw new IllegalArgumentException("expected to have " + testName);
        }
        if (latestUpdate.testEdit == null) {
            throw new IllegalArgumentException("unexpectedly " + testName + " is deleted.");
        }

        return latestUpdate.testEdit.definition;
    }

    private TestState getTestState(final String testName) {
        final UpdateRecord latestUpdate = getLatestUpdate(testName);
        if (latestUpdate == null) {
            return TestState.NOT_CREATED;
        }

        final TestEdit testEdit = Objects.requireNonNull(latestUpdate.testEdit);
        if (testEdit.definition == null) {
            return TestState.DELETED;
        } else {
            return TestState.ALIVE;
        }
    }

    private enum TestState {
        // no history
        NOT_CREATED,
        // created and not deleted
        ALIVE,
        // created and deleted.
        DELETED,
    }

    private void checkRevisionIsKnown(final RevisionId revisionId) throws StoreException {
        if (!revisionIdIndex.containsKey(revisionId)) {
            throw new StoreException("Unknown revision " + revisionId);
        }
    }

    private static class RevisionIdGenerator {
        private final LongSupplier sequentialNumberGenerator;

        private RevisionIdGenerator(
                final LongSupplier sequentialNumberGenerator
        ) {
            this.sequentialNumberGenerator = sequentialNumberGenerator;
        }

        private RevisionId generate() {
            return new RevisionId(sequentialNumberGenerator.getAsLong());
        }
    }

    private static class RevisionId {
        private final long id;

        private RevisionId(final long id) {
            this.id = id;
        }

        private static RevisionId parse(
                final String value
        ) throws StoreException {
            try {
                return new RevisionId(Long.parseLong(value));
            } catch (final NumberFormatException e) {
                throw new StoreException("Invalid revision format " + value, e);
            }
        }

        private boolean isSameOrAfter(final Revision r) {
            return id >= Long.parseLong(r.getRevision());
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            final RevisionId that = (RevisionId) o;
            return id == that.id;
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }

        @Override
        public String toString() {
            return Long.toString(id);
        }
    }

    private static class UpdateRecord {
        private final Revision revision;
        @Nullable
        private final TestEdit testEdit;

        private UpdateRecord(
                final Revision revision,
                @Nullable final TestEdit testEdit
        ) {
            this.revision = Objects.requireNonNull(revision);
            this.testEdit = testEdit;
        }

        private RevisionDetails toRevisionDetails() {
            return new RevisionDetails(
                    revision,
                    modifiedTests()
            );
        }

        private Set<String> modifiedTests() {
            return this.testEdit == null
                    ? Collections.emptySet()
                    : Collections.singleton(testEdit.testName);
        }
    }

    private static class TestEdit {
        private final String testName;
        @Nullable
        private final TestDefinition definition;

        private TestEdit(
                final String testName,
                @Nullable final TestDefinition definition
        ) {
            this.testName = Objects.requireNonNull(testName);
            this.definition = definition;
        }
    }
}
